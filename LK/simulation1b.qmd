# First script for Simulation Study 1b

```{r}
set.seed(1)
```

# Packages

Copied and pasted from original paper.

```{r}
library(GPArotation)
library(CDM)
library(miceadds)
library(TAM)
library(sirt)
library(lavaan)

#new packages
library(dplyr)
library(tidyr)
```

# Specify 2-factor-Model
```{r}
model <- "

#Structural part
    FX =~ l1*X1 + l2*X2 + l3*X3
    FY =~ l4*Y1 + l5*Y2 + l6*Y3
    FX ~~ 1*FX    #Fixed latent variance
    FY ~~ 1*FY    #Fixed latent variance
    FX ~~ phi*FY
    phi < 0.99    #Phi between -1 and 1
    phi > -0.99

#Measurement part    
    X1 ~~ vX1*X1
    X2 ~~ vX2*X2    
    X3 ~~ vX3*X3
    Y1 ~~ vY1*Y1
    Y2 ~~ vY2*Y2    
    Y3 ~~ vY3*Y3
    l1 > 0.01     #only positive loadings
    l2 > 0.01    
    l3 > 0.01
    l4 > 0.01
    l5 > 0.01
    l6 > 0.01       
    vX1 > 0.01    #only positive variances
    vX2 > 0.01    
    vX3 > 0.01
    vY1 > 0.01
    vY2 > 0.01    
    vY3 > 0.01
                #residual correlations
    X1 ~~ Y1
    X2 ~~ Y2
    "
```

# Setup and Design

```{r}
setup_design <- function() {
  
  #N
  N_sizes <- c(50, 100)
  
  # Factor loadings
  lambda_values <- c(0.4, 0.5, 0.6, 0.7, 0.8)
  
  # Factor correlations
  phi_values <- c(0, 0.2, 0.4, 0.6, 0.8)
  
  # Expand grid to create a data frame of all combinations
  design <- expand.grid(N_sizes = N_sizes, 
                        lambda = lambda_values, 
                        phi = phi_values)
  
  return(design)
}


```

# Data generating Mechanism
```{r}
get_dgm <- function(lambda, phi) {
  # Factor loadings for all six manifest variables set to the specified lambda
  LAM <- matrix(c(lambda, lambda, lambda, lambda, lambda, lambda), nrow = 6, ncol = 2, byrow = TRUE)
  LAM[1:3, 2] <- 0  # Setting off-diagonal elements to 0
  LAM[4:6, 1] <- 0  
  
  # Factor correlation matrix
  PHI <- matrix(c(1, phi, phi, 1), nrow = 2, ncol = 2)
  
  # Theta
  error_variances <- 1 - lambda^2  
  THETA <- diag(c(rep(error_variances, 6)))  
  
  # residual correlations are directly specified 
  THETA[1, 4] <- THETA[4, 1] <- 0.12  
  THETA[2, 5] <- THETA[5, 2] <- 0.12 

  return(list(LAM = LAM, PHI = PHI, THETA = THETA))
}


```

# Simulate data
```{r}
simulate_data <- function(N, lambda, phi) {
  # Get DGM parameters
  dgm_params <- get_dgm(lambda, phi)
  LAM <- dgm_params$LAM
  PHI <- dgm_params$PHI
  THETA <- dgm_params$THETA
  
  # The covariance matrix S 
  S <- LAM %*% PHI %*% t(LAM) + THETA
  rownames(S) <- colnames(S) <- c(paste0("X", 1:3), paste0("Y", 1:3))
  
  # Generate data
  dat <- MASS::mvrnorm(n = N, mu = rep(0, 6), Sigma = S)
  df_dat <- as.data.frame(dat)
  names(df_dat) <- c("X1", "X2", "X3", "Y1", "Y2", "Y3")
  
  return(df_dat)
}


```

# Planned Analysis
```{r}
#Specify estimation methods of interest
models <- c("LSAM_ML", "LSAM_ULS")

planned_analysis <- function(N, lambda, phi, model, model_type) {
  dataset <- simulate_data(N, lambda, phi)
  
  if (model_type == "LSAM_ML") {
    fit <- lavaan::sam(model, data=dataset, sam.method="local", estimator = "ML", std.lv= TRUE)
  } else if (model_type == "LSAM_ULS") {
    fit <- lavaan::sam(model, data=dataset, sam.method="local", estimator = "ULS", std.lv= TRUE)
  } else {
    stop("Unknown model type specified")
  }
  
  estimates <- parameterEstimates(fit)
  phi_estimate <- subset(estimates, label == "phi")$est
  return(phi_estimate)
}


```

#  Simulation Study
```{r}
simulation_study <- function(design, model, num_repetitions, models) {
  # Initialize an empty dataframe to store the results
  results_df <- data.frame(
    ModelType = character(),
    N = integer(),
    Lambda = numeric(),
    Phi = numeric(),
    AvgAbsBias = numeric(),
    stringsAsFactors = FALSE
  )
  
  for(model_type in models) {
    for(i in 1:nrow(design)) {
      row <- design[i, ]
      N <- row$N_sizes
      lambda <- row$lambda
      phi_true <- row$phi  # Use phi from the design matrix as the true value
      
      phi_estimates <- replicate(num_repetitions, {
        planned_analysis(N, lambda, phi_true, model, model_type)
      }, simplify = "array")
      
      # Calculate the average absolute bias of the estimated phi
      avg_abs_bias <- mean(abs(phi_estimates - phi_true))
      
      # Append the results to the results dataframe
      results_row <- data.frame(
        ModelType = model_type,
        N = N,
        Lambda = lambda,
        Phi = phi_true,
        AvgAbsBias = avg_abs_bias
      )
      
      results_df <- rbind(results_df, results_row)
    }
  }
  
  return(results_df)
}



```

## RUN
```{r}
design <- setup_design()
models <- c("LSAM_ML", "LSAM_ULS")  # Models to test
num_repetitions <- 2

# Execute the simulation study
results_df <- simulation_study(design, model, num_repetitions, models)

# View the results
print(results_df)


```

# Report analysis
```{r}
report_analysis <- function(results_df) {
  # List to store the final tables
  tables_list <- list()
  
  # Extract unique model types and N values
  model_types <- unique(results_df$ModelType)
  N_values <- unique(results_df$N)
  
  # Create a table for each combination of ModelType and N
  for (model in model_types) {
    for (N_size in N_values) {
      
      # Filter the dataframe for the current ModelType and N
      subset_df <- results_df %>%
        filter(ModelType == model, N == N_size)%>%
        mutate(AvgAbsBias = round(AvgAbsBias, 2))
      
      # Pivot the dataframe to wide format with Lambda as rows and Phi as columns
      wide_df <- subset_df %>%
        select(Lambda, Phi, AvgAbsBias) %>%
        pivot_wider(names_from = Phi, values_from = AvgAbsBias, names_prefix = "Phi_") %>%
        arrange(Lambda)

      # Create a name for each table based on ModelType and N
      table_name <- paste0(model, "_N_", N_size)
      tables_list[[table_name]] <- wide_df
    }
  }
  
  return(tables_list)
}

# Run the function with results
list_of_tables <- report_analysis(results_df)

# Access a specific table
LSAM_ML_N_50 <- list_of_tables[["LSAM_ML_N_50"]] 

#display all tables
report_analysis(results_df)
```


