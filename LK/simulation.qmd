# First script for Simulation Study 1

Used for writing or coding?

relevant components:

# Packages

Copied and pasted from original paper.

```{r}
library(GPArotation)
library(CDM)
library(miceadds)
library(TAM)
library(sirt)
library(lavaan)

#new packages
library(future.apply)
library(dplyr)
```

# Set up file structure
```{r}
1+1


```

# Source relevant R Functions

# Specify 2-factor-Model
```{r}
model <- "

#Structural part
    FX =~ l1*X1 + l2*X2 + l3*X3
    FY =~ l4*Y1 + l5*Y2 + l6*Y3
    FX ~~ 1*FX    #Fixed latent variance
    FY ~~ 1*FY    #Fixed latent variance
    FX ~~ phi*FY
    phi < 0.99    #Phi between -1 and 1
    phi > -0.99

#Measurement part    
    X1 ~~ vX1*X1
    X2 ~~ vX2*X2    
    X3 ~~ vX3*X3
    Y1 ~~ vY1*Y1
    Y2 ~~ vY2*Y2    
    Y3 ~~ vY3*Y3
    l1 > 0.01     #only positive loadings
    l2 > 0.01    
    l3 > 0.01
    l4 > 0.01
    l5 > 0.01
    l6 > 0.01       
    vX1 > 0.01    #only positive variances
    vX2 > 0.01    
    vX3 > 0.01
    vY1 > 0.01
    vY2 > 0.01    
    vY3 > 0.01   
    "
```

# Set estimators

```{r}

# SEM ML
mod00 <- lavaan::sem(model, sample.cov=S, sample.nobs=1e5, estimator="ML", std.lv= TRUE)

# SEM ULS
mod01 <- lavaan::sem(model, sample.cov=S, sample.nobs=1e5, estimator="ULS", std.lv= TRUE)

# LSAM ML
mod0a <- lavaan::sam(model, sample.cov=S, sample.nobs=1e5, sam.method="local", estimator = "ML", std.lv= TRUE)

#LSAM ULS
mod0b <- lavaan::sam(model, sample.cov=S, sample.nobs=1e5, sam.method="local", estimator = "ULS", std.lv= TRUE)

#GSAM

mod1a <- sam(model, sample.cov=S, sample.nobs=1e5, sam.method = "global", estimator = "ML", std.lv= TRUE )

mod1b <- sam(model, sample.cov=S, sample.nobs=1e5, sam.method = "global", estimator = "ULS", std.lv = TRUE )


parameterEstimates(mod0a)

summary(mod00)




```

# Setup and Design

```{r}
setup_design <- function() {
  # Sample sizes
  N_sizes <- c(50, 100, 250, 500, 1000, 2500, 10^5)
  
  # Misspecification conditions: (0, 1, 2) correlated residuals, and psi values
  rc_conditions <- c(0, 1, 2)
  psi_values <- c(0.12, -0.12)
  
  # Expand grid to create a data frame of all combinations
  design <- expand.grid(N_sizes = N_sizes, rc_conditions = rc_conditions, psi_values = psi_values)
  
  # Adjust for the condition where rc is 0 (correlated residuals are not considered)
  design <- design[!(design$rc_conditions == 0 & design$psi_values != 0.12), ]
  
  return(design)
}

```

# Data generating Mechanism
```{r}
get_dgm <- function(rc, psi_value) {
  lam1 <- 0.55
  lam2 <- 0.45
  phi <- 0.60
  
  LAM <- matrix(0, nrow=6, ncol=2)
  LAM[1:3, 1] <- lam1
  LAM[4:6, 2] <- lam2
  
  PHI <- matrix(0, nrow=2, ncol=2)
  diag(PHI) <- 1
  PHI[1, 2] <- PHI[2, 1] <- phi
  
  THETA <- diag(c(rep(1-lam1^2, 3), rep(1-lam2^2, 3)))
  
  # Adjust THETA for misspecification
  if (rc >= 1) {
    THETA[1, 4] <- THETA[4, 1] <- psi_value
  }
  if (rc == 2) {
    THETA[2, 5] <- THETA[5, 2] <- psi_value
  }
  
  return(list(LAM = LAM, PHI = PHI, THETA = THETA))
}

```

# Simulate data
```{r}
simulate_data <- function(N, rc, psi_value) {
  # Get DGM parameters
  dgm_params <- get_dgm(rc, psi_value)
  LAM <- dgm_params$LAM
  PHI <- dgm_params$PHI
  THETA <- dgm_params$THETA
  
  S <- LAM %*% PHI %*% t(LAM) + THETA
  rownames(S) <- colnames(S) <- c(paste0("X", 1:3), paste0("Y", 1:3))
  
  # Generate data
  dat <- MASS::mvrnorm(n = N, mu = rep(0, 6), Sigma = S)
  df_dat <- as.data.frame(dat)
  names(df_dat) <- c("X1", "X2", "X3", "Y1", "Y2", "Y3")
  
  return(list(SampleSize = N, RC = rc, PsiValue = psi_value, Data = df_dat))
}

```

#Implementing test
```{r}
# Generate the setup
design <- setup_design()

# Example: Apply simulate_data function for the first row of the design
# This is where you would loop or apply across all rows in 'design'
simulated_dataset <- simulate_data(N = design$N_sizes[1], rc = design$rc_conditions[1], psi_value = design$psi_values[1])

# Complete simualtion does not work yet
simulated_datasets <- simulate_data()

```

# Planned Analysis
```{r}
planned_analysis <- function(N, rc, psi_value, model) {
  # Simulate data for the given condition
  dataset <- simulate_data(N, rc, psi_value)$Data
  
  # Fit the model using the lavaan package
  fit <- lavaan::sem(model, data=dataset, estimator="ML", std.lv= TRUE)
  
  # Extract the estimated phi parameter
  estimates <- lavaan::parameterEstimates(fit)
  phi_estimate <- subset(estimates, label == "phi")$est
  
  return(phi_estimate)
}

```


# Simulation study
```{r}
simulation_study <- function(design, model) {
  # Optionally, set up parallel processing
  # plan(multisession)
  
  results <- future.apply::future_lapply(1:nrow(design), function(i) {
    row <- design[i, ]
    phi_estimate <- planned_analysis(row$N_sizes, row$rc_conditions, row$psi_values, model)
    return(c(N = row$N_sizes, RC = row$rc_conditions, PsiValue = row$psi_values, PhiEstimate = phi_estimate))
  }, future.seed = TRUE)
  
  # Convert results to a dataframe
  results_df <- do.call(rbind, results) %>% as.data.frame(stringsAsFactors = FALSE)
  return(results_df)
}

```

# RUN
```{r}
results_df <- simulation_study(design, model)

print(results_df)

```








# Old ideas

# planned_analysis
Open questions: 

- How exactly do we compute Bias, SD and RMSE for the estimated factor correlation?
Absolute vs. relative vs. mean bias in first studies?



- What data argument to use? 'data=simulated_datasets[[1]]$Data' vs. 'sample.cov=S, sample.nobs=1e5' ?
Looks like the use of the 2nd is wrong, as it does not vary the number of observation in the original script. I need to do it in a way that it can be varied within a function.

```{r}
#Performance measures need to be extracted for each condition
#Below, just mathematical computation, does not work so commented out

#average_absolute_bias <- mean(abs(estimates - true_values))
#average_relative_bias <- mean((estimates - true_values) / true_values) 

# From Robitzsch
# Here, we extract the parameter values of interest (phi) from the model
mod00 <- lavaan::sem(model, sample.cov=S, sample.nobs=1e5, estimator="ML", std.lv= TRUE)
summary(mod00)
pars <- scan.vec("phi")
cp <- coef(mod00)
est_values <- cp[pars]
true_values <- c(phi)

#Compute biases, only one value here always, as no 1500 replications yet
absolute_bias <- abs(est_values - true_values)
relative_bias <- (est_values - true_values) / true_values 

#Mean bias after all replications are done
#df$PhiDiff = df$EstimatedPhi - df$TruePhi
#mean_bias = mean(df$PhiDiff)

# Standard Deviation (SD) of the estimated phi after all replications
#sd_estimated_phi = sd(df$EstimatedPhi)

# Compute Root Mean Square Error (RMSE) after all replications
#rmse = sqrt(mean(df$PhiDiff^2))



# He uses this function as basis to concatenate data frames iteratively for all estimators. These are then scored as a data frame in the final results.
define_dfr1 <- function()
{
    cp <- coef(mod1a)
    dfr1 <- data.frame( design_dd, model=model_name , par=pars, true=true_values, delta=delta,
                        est=est_values,  AbsoluteBias=absolute_bias,RelativeBias=relative_bias )
    return(dfr1)
}

```

# report_analysis
```{r}
#Display of results so that it matches original paper


```






