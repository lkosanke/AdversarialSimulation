# First script for Simulation Study 2

```{r}
set.seed(1)
```



# Packages

Copied and pasted from original paper.

```{r}
library(GPArotation)
library(CDM)
library(miceadds)
library(TAM)
library(sirt)
library(lavaan)

#new packages
library(dplyr)
library(tidyr)
```

# Specify 2-factor-Model

```{r}
model <- "

#Structural part
    FX =~ l1*X1 + l2*X2 + l3*X3
    FY =~ l4*Y1 + l5*Y2 + l6*Y3
    FX ~~ 1*FX    #Fixed latent variance
    FY ~~ 1*FY    #Fixed latent variance
    FX ~~ phi*FY
    phi < 0.99    #Phi between -1 and 1
    phi > -0.99

#Measurement part    
    X1 ~~ vX1*X1
    X2 ~~ vX2*X2    
    X3 ~~ vX3*X3
    Y1 ~~ vY1*Y1
    Y2 ~~ vY2*Y2    
    Y3 ~~ vY3*Y3
    l1 > 0.01     #only positive loadings
    l2 > 0.01    
    l3 > 0.01
    l4 > 0.01
    l5 > 0.01
    l6 > 0.01       
    vX1 > 0.01    #only positive variances
    vX2 > 0.01    
    vX3 > 0.01
    vY1 > 0.01
    vY2 > 0.01    
    vY3 > 0.01   
    "
```

# Setup and Design

```{r}
setup_design <- function() {
  
  # Sample sizes
  N_sizes <- c(50, 100, 250, 500, 1000, 2500, 10^5)
  
  # Cross-loading conditions
  cl_conditions <- c(1, 2)
  
  # Delta values for cross-loadings, if present, take values of either 0.3 or -0.3
  delta_values <- c(0.3, -0.3)
  
  design <- expand.grid(N_sizes = N_sizes, 
                        cl_conditions = cl_conditions, 
                        delta_value = delta_values)


  return(design)
}


```

# Data generating Mechanism

## Fixed values
```{r}
lam1 <- 0.55
lam2 <- 0.45
phi <- 0.60

LAM <- matrix(0, nrow=6, ncol=2)
LAM[1:3, 1] <- lam1
LAM[4:6, 2] <- lam2

PHI <- matrix(0, nrow=2, ncol=2)
diag(PHI) <- 1
PHI[1, 2] <- PHI[2, 1] <- phi

THETA <- diag(c(rep(1-lam1^2, 3), rep(1-lam2^2, 3)))

#Don't need Beta in this study
```

## Varying values
```{r}
get_dgm <- function(cl, delta_value) {
  
  # Apply cross-loadings based on the condition
  if (cl >= 1) {
    LAM[1, 2] <- delta_value
  } 
  if (cl == 2) {
    LAM[4, 1] <- delta_value
  }
  
  MLIST <-list(LAM = LAM, PHI = PHI, THETA = THETA)
  return(MLIST)
}


```

# Apply Syntax
```{r}
apply_syntax <- function(model, MLIST) {
  
  LAM <- MLIST$LAM
  
  pop.model <- paste(
"#Structural part",
    paste("FX =~", LAM[1,1], "*X1 +", LAM[2,1], "*X2 +", LAM[3,1], "*X3"),
    paste("FY =~", LAM[4,2], "*Y1 +", LAM[5,2], "*Y2 +", LAM[6,2], "*Y3"),
    "FX ~~ 1*FX",    
    "FY ~~ 1*FY",    
    paste("FX ~~", PHI[1,2], "*FY"),
"#Measurement part",    
    paste("X1 ~~", THETA[1,1], "*X1"),
    paste("X2 ~~", THETA[2,2], "*X2"),
    paste("X3 ~~", THETA[3,3], "*X3"),
    paste("Y1 ~~", THETA[4,4], "*Y1"),
    paste("Y2 ~~", THETA[5,5], "*Y2"),
    paste("Y3 ~~", THETA[6,6], "*Y3"),
    sep = "\n"
  ) 

  # Conditionally add cross-loadings if rc > 0
  if (LAM[1, 2] != 0) {
        pop.model <- paste(
                            "#Structural part",
                                paste("FX =~", LAM[1,1], "*X1 +", LAM[2,1], "*X2 +", LAM[3,1], "*X3"),
                                paste("FY =~", LAM[4,2], "*Y1 +", LAM[5,2], "*Y2 +", LAM[6,2], "*Y3 +", LAM[1, 2], "*X1"),
                                "FX ~~ 1*FX",    
                                "FY ~~ 1*FY",    
                                paste("FX ~~", PHI[1,2], "*FY"),
                            "#Measurement part",    
                                paste("X1 ~~", THETA[1,1], "*X1"),
                                paste("X2 ~~", THETA[2,2], "*X2"),
                                paste("X3 ~~", THETA[3,3], "*X3"),
                                paste("Y1 ~~", THETA[4,4], "*Y1"),
                                paste("Y2 ~~", THETA[5,5], "*Y2"),
                                paste("Y3 ~~", THETA[6,6], "*Y3"),
                                sep = "\n"
                              )
    }
    if (LAM[4, 1] != 0) {
        pop.model <- paste(
                            "#Structural part",
                                paste("FX =~", LAM[1,1], "*X1 +", LAM[2,1], "*X2 +", LAM[3,1], "*X3 +", LAM[4, 1], "*Y1"),
                                paste("FY =~", LAM[4,2], "*Y1 +", LAM[5,2], "*Y2 +", LAM[6,2], "*Y3 +", LAM[1, 2], "*X1"),
                                "FX ~~ 1*FX",    
                                "FY ~~ 1*FY",    
                                paste("FX ~~", PHI[1,2], "*FY"),
                            "#Measurement part",    
                                paste("X1 ~~", THETA[1,1], "*X1"),
                                paste("X2 ~~", THETA[2,2], "*X2"),
                                paste("X3 ~~", THETA[3,3], "*X3"),
                                paste("Y1 ~~", THETA[4,4], "*Y1"),
                                paste("Y2 ~~", THETA[5,5], "*Y2"),
                                paste("Y3 ~~", THETA[6,6], "*Y3"),
                                sep = "\n"
                              )
    }
  
  return(pop.model)
}

model_syntax <-apply_syntax(model,get_dgm(1,-0.3))
cat(model_syntax)

```

# Simulate data
```{r}
simulate_data <- function(N, cl, delta_value, model) {
  # Get DGM parameters
  dgm_params <- get_dgm(cl, delta_value)

  pop.model <- apply_syntax(model, dgm_params)
  
  df_dat <- simulateData(pop.model, sample.nobs = N)
  
  return(df_dat)
}


```

# Planned Analysis
```{r}
#Specify estimation methods of interest
models <- c("SEM_ML", "SEM_ULS", "LSAM_ML", "LSAM_ULS", "GSAM_ML", "GSAM_ULS")

planned_analysis <- function(N, cl, delta_value, model, model_type) {

  dataset <- simulate_data(N, cl, delta_value)$Data
  
  if (model_type == "SEM_ML") {
    fit <- lavaan::sem(model, data=dataset, estimator="ML", std.lv= TRUE)
  } else if (model_type == "SEM_ULS") {
    fit <- lavaan::sem(model, data=dataset, estimator="ULS", std.lv= TRUE)
  } else if (model_type == "LSAM_ML") {
    fit <- lavaan::sam(model, data=dataset, sam.method="local", estimator = "ML", std.lv= TRUE)
  } else if (model_type == "LSAM_ULS") {
    fit <- lavaan::sam(model, data=dataset, sam.method="local", estimator = "ULS", std.lv= TRUE)
  } else if (model_type == "GSAM_ML") {
    fit <- lavaan::sam(model, data=dataset, sam.method = "global", estimator = "ML", std.lv= TRUE)
  } else if (model_type == "GSAM_ULS") {
    fit <- lavaan::sam(model, data=dataset, sam.method = "global", estimator = "ULS", std.lv= TRUE)
  } else {
    stop("Unknown model type specified")
  }
  
  estimates <- parameterEstimates(fit)
  phi_estimate <- subset(estimates, label == "phi")$est
  return(phi_estimate)
}


```

#  Simulation Study
```{r}
simulation_study <- function(design, model, num_repetitions, models) {
  # Initialize empty dataframe
  results_df <- data.frame(
    ModelType = character(),
    N = integer(),
    CL = integer(),
    DeltaValue = numeric(),
    AvgAbsBias = numeric(),
    SDPhi = numeric(),
    RMSEPhi = numeric(),
    stringsAsFactors = FALSE
  )
  
  for(model_type in models) {
    for(i in 1:nrow(design)) {
      row <- design[i, ]
      phi_estimates <- replicate(num_repetitions, {
        planned_analysis(row$N_sizes, row$cl_conditions, row$delta_value, model, model_type)
      })
      
      # Compute metrics directly
      avg_abs_bias <- mean(abs(phi_estimates - phi))
      sd_phi <- sd(phi_estimates)
      rmse_phi <- sqrt(mean((phi_estimates - phi)^2))
      
      # Combine the results into a single row
      results_row <- data.frame(
        ModelType = model_type,
        N = row$N_sizes,
        CL = row$cl_conditions,
        DeltaValue = row$delta_value,
        AvgAbsBias = avg_abs_bias,
        SDPhi = sd_phi,
        RMSEPhi = rmse_phi
      )
      
      # Bind the row to the results dataframe
      results_df <- rbind(results_df, results_row)
    }
  }
  
  return(results_df)
}


```

## RUN
```{r}
design <- setup_design()
models <- c("SEM_ML", "SEM_ULS", "LSAM_ML", "LSAM_ULS", "GSAM_ML", "GSAM_ULS")  # Models to test
num_repetitions <- 2

# Execute the simulation study
results_df <- simulation_study(design, model, num_repetitions, models)

# View the results
print(results_df)


```

# Report analysis
```{r}
report_analysis <- function(results_df, models) {
  # Define the list to store the tables
  tables_list <- list()

  # Define the unique CL conditions and delta values
  unique_cl <- unique(results_df$CL)
  unique_delta <- unique(results_df$DeltaValue)

  # Define metric names to iterate over
  metrics <- c("Bias", "SD", "RMSE")

  # Loop through each CL condition and deltaValue to create separate tables for each metric
  for (cl in unique_cl) {
    for (delta in unique_delta) {
      # Filter for the current CL and deltaValue
      subset_df <- results_df %>%
        filter(CL == cl, DeltaValue == delta) %>%
        mutate(ModelType = factor(ModelType, levels = models)) # Ensure ModelType order

      # Loop through each metric to pivot and create tables
      for (metric in metrics) {
        # Identify columns related to the current metric
        metric_colnames <- grep(metric, names(subset_df), value = TRUE)
        
        # Pivot the dataframe to a wide format for the current metric and reorder rows
        wide_df <- subset_df %>%
          select(ModelType, N, all_of(metric_colnames)) %>%
          arrange(ModelType) %>% # Arrange rows by ModelType
          pivot_longer(cols = all_of(metric_colnames), names_to = "Metric", values_to = "Value") %>%
          mutate(Value = round(Value, 2)) %>% # Round the values
          pivot_wider(names_from = N, values_from = Value) %>%
          select(-Metric)

        # Generate the table name based on the condition and metric
        condition_label <- paste("CL", cl, "Delta", delta, sep = "_")
        table_name <- paste(metric, condition_label, sep = "_")
        
        # Store the table in the list with the corrected naming
        tables_list[[table_name]] <- wide_df
      }
    }
  }
  
  return(tables_list)
}

list_of_tables <- report_analysis(results_df, models)

# Access a specific table
bias_no_res_table <- list_of_tables[["Bias_CL_1_Delta_0.3"]] # Example for Bias with 1 cross-loading of value 0.3

#display all tables
report_analysis(results_df, models)
```


