# First script for Simulation Study 1

Used for writing or coding?


```{r}
set.seed(1)
```



# Packages

Copied and pasted from original paper.

```{r}
library(GPArotation) 
library(CDM)
library(miceadds)
library(TAM)
library(sirt)
library(lavaan)

#new packages
library(dplyr)
library(tidyr)
```

# Source relevant R Functions

# Specify 2-factor-Model
label is missing for "phi", but not relevant anyway, as multiple factor correlations?
Have to look into define_fr1() function to see which parameters exactly are extracted how

I think the model has to be a standard 5 factor model with std.lv as before, so fixed latent variance, only positive loadings and residual variances.

```{r}
model <- "

#Structural part
    F1 =~ l1*y1 + l2*y2 + l3*y3
    F2 =~ l4*y4 + l5*y5 + l6*y6
    F3 =~ l7*y7 + l8*y8 + l9*y9
    F4 =~ l10*y10 + l11*y11 + l12*y12
    F5 =~ l13*y13 + l14*y14 + l15*y15
    
#Fixed latent variances    
    F1 ~~ 1*F1    
    F2 ~~ 1*F2
    F3 ~~ 1*F3
    F4 ~~ 1*F4
    F5 ~~ 1*F5
    
#Covariances
    F1 ~~ phi21*F2
    F2 ~~ phi52*F5
    
#Regressions
    F3 ~ phi31*F1
    F4 ~ phi41*F1
    F5 ~ phi51*F1
    F3 ~ phi32*F2
    F4 ~ phi42*F2
    F5 ~ phi53*F3
    F3 ~ phi43*F4
    F5 ~ phi54*F4

#Measurement part    
    y1 ~~ vY1*y1
    y2 ~~ vY2*y2    
    y3 ~~ vY3*y3
    y4 ~~ vY4*y4
    y5 ~~ vY5*y5    
    y6 ~~ vY6*y6
    y7 ~~ vY7*y7
    y8 ~~ vY8*y8
    y9 ~~ vY9*y9
    y10 ~~ vY10*y10
    y11 ~~ vY11*y11
    y12 ~~ vY12*y12
    y13 ~~ vY13*y13
    y14 ~~ vY14*y14
    y15 ~~ vY15*y15

#only positive loadings    
    l1 > 0.01          
    l2 > 0.01    
    l3 > 0.01
    l4 > 0.01
    l5 > 0.01
    l6 > 0.01
    l7 > 0.01
    l8 > 0.01
    l9 > 0.01
    l10 > 0.01
    l11 > 0.01
    l12 > 0.01
    l13 > 0.01
    l14 > 0.01
    l15 > 0.01
    
#only positive variances    
    vY1 > 0.01    
    vY2 > 0.01    
    vY3 > 0.01
    vY4 > 0.01
    vY5 > 0.01    
    vY6 > 0.01
    vY7 > 0.01
    vY8 > 0.01
    vY9 > 0.01
    vY10 > 0.01
    vY11 > 0.01
    vY12 > 0.01
    vY13 > 0.01
    vY14 > 0.01
    vY15 > 0.01
    
    "


```

# Setup and Design

```{r}
setup_design <- function() {
  # Sample sizes
  N_sizes <- c(50, 100, 250, 500, 1000, 2500, 10^5)
  
  # DGM conditions
  DGM_types <- c(1,2,3)
  
  # Expand grid to create a data frame of all combinations
  design <- expand.grid(N_sizes = N_sizes, DGM_types = DGM_types)
  
  return(design)
}

```

# Get Data generating Mechanisms
```{r}
#Set up DGM's 1-3 as list
covmat_list <- list()
covmat_list[[1]] <- read.table("rl_simulation_true_model1__COVMAT.txt", header=TRUE)
covmat_list[[2]] <- read.table("rl_simulation_true_model2__COVMAT.txt", header=TRUE)
covmat_list[[3]] <- read.table("rl_simulation_true_model3__COVMAT.txt", header=TRUE)

```

# Simulate data
```{r}
simulate_data <- function(N, DGM) {
  
  S <- covmat_list[[DGM]]
  
  # Number of variables is the number of columns in the covariance matrix
  NV <- ncol(S)
  
  # Generate data
  dat <- MASS::mvrnorm(n = N, mu = rep(0, NV), Sigma = S)
  df_dat <- as.data.frame(dat)
  
  return(df_dat)
}

```

# Planned Analysis
Here, I need to include the model variation for the 3 DGM

```{r}
#Specify estimation methods of interest
models <- c("SEM_ML", "LSAM_ML", "GSAM_ML")

# Planned analysis

planned_analysis <- function(N, DGM, model, model_type) {
  dataset <- simulate_data(N, DGM)$Data
  
  if (model_type == "SEM_ML") {
    fit <- lavaan::sem(model, data=dataset, estimator="ML", std.lv= TRUE)
  } else if (model_type == "LSAM_ML") {
    fit <- lavaan::sam(model, data=dataset, sam.method="local", estimator = "ML", std.lv= TRUE)
  } else if (model_type == "GSAM_ML") {
    fit <- lavaan::sam(model, data=dataset, sam.method = "global", estimator = "ML", std.lv= TRUE)
  } else {
    stop("Unknown model type specified")
  }
  
  estimates <- parameterEstimates(fit)

  phi_patterns <- c("phi21", "phi31", "phi41", "phi51", "phi32", "phi42", "phi43", "phi52", "phi53", "phi54")
  phi_estimates <- sapply(phi_patterns, function(phi) {
    if (any(estimates$label == phi)) {
      return(estimates$est[estimates$label == phi])
    } else {
      return(NA)  # Return NA if the parameter wasn't found
    }
  }, simplify = FALSE, USE.NAMES = TRUE)
  
  return(phi_estimates)
}


```

#  Simulation Study
```{r}
simulation_study <- function(design, model, num_repetitions, true_phis, models) {
  # Initialize an empty list to store the results for each phi parameter
  results_list <- list()
  
  for(model_type in models) {
    for(i in 1:nrow(design)) {
      row <- design[i, ]
      
      # Initialize matrices to store estimates across repetitions for each phi
      phi_estimates_matrix <- matrix(NA, nrow = num_repetitions, ncol = length(true_phis))
      names(phi_estimates_matrix) <- names(true_phis)
      
      for(rep in 1:num_repetitions) {
        estimates_list <- planned_analysis(row$N_sizes, row$DGM_types, model, model_type)
        
        # Assuming estimates_list is a named list of phi estimates from planned_analysis
        phi_estimates_matrix[rep, ] <- sapply(names(true_phis), function(phi_name) {
          if(!is.null(estimates_list[[phi_name]])) {
            return(as.numeric(estimates_list[[phi_name]]))
          } else {
            return(NA) # In case some phi estimates are missing
          }
        })
      }
      
      # Compute metrics for each phi
      avg_abs_bias <- colMeans(abs(phi_estimates_matrix - true_phis), na.rm = TRUE)
      rmse_phi <- sqrt(colMeans((phi_estimates_matrix - true_phis)^2, na.rm = TRUE))
      
      # Combine the results for this design row and model type
      results_row <- data.frame(
        ModelType = model_type,
        N = row$N_sizes,
        DGM = row$DGM_types,
        AvgAbsBias = avg_abs_bias,
        RMSEPhi = rmse_phi,
        stringsAsFactors = FALSE
      )
      
      # Bind the row to the results list (now handling multiple metrics)
      results_list[[length(results_list) + 1]] <- results_row
    }
  }
  
  # Combine all results into a single data frame
  results_df <- do.call(rbind, results_list)
  
  return(results_df)
}


```

## RUN
```{r}
design <- setup_design()
true_phis <- c(phi21 = 0.00, phi31 = 0.11, phi32 = 0.11, phi41 = 0.10, phi42 = 0.10, phi43 = 0.12, phi51 = 0.12, phi52 = 0.02, phi53 = 0.12, phi54 = 0.12)
models <- c("SEM_ML", "LSAM_ML", "GSAM_ML")
num_repetitions <- 2

# Execute the simulation study
results_df <- simulation_study(design, model, num_repetitions, true_phis, models)

# View the results
print(results_df)


```

# Report analysis
```{r}
report_analysis <- function(results_df, models) {
  # Define the list to store the tables
  tables_list <- list()

  # Define the different RC conditions and the corresponding labels
  unique_rc <- unique(results_df$RC)
  unique_psi <- unique(results_df$PsiValue)

  # Define metric names to iterate over
  metrics <- c("Bias", "SD", "RMSE")

  # Loop through each RC condition and PsiValue to create separate tables for each metric
  for (rc in unique_rc) {
    for (psi in unique_psi) {
      # Skip creation for non-existing conditions (RC == 0 and PsiValue is negative)
      if (rc == 0 && psi < 0) {
        next
      }
      
      # Filter for the current RC and PsiValue
      subset_df <- results_df %>%
        filter(RC == rc, PsiValue == psi) %>%
        mutate(ModelType = factor(ModelType, levels = models)) # Use the models object here

      # Loop through each metric to pivot and create tables
      for (metric in metrics) {
        metric_colnames <- grep(metric, names(subset_df), value = TRUE)
        
        # Pivot the dataframe to a wide format for the current metric and reorder rows
        wide_df <- subset_df %>%
          select(ModelType, N, all_of(metric_colnames)) %>%
          arrange(ModelType) %>% # Arrange rows by ModelType
          pivot_longer(cols = all_of(metric_colnames), names_to = "Metric", values_to = "Value") %>%
          mutate(Value = round(Value, 2)) %>% # Round the values
          pivot_wider(names_from = N, values_from = Value) %>%
          select(-Metric)
        
        # Generate the table name based on the condition and metric
        psi_label <- ifelse(psi == 0, "0", ifelse(psi > 0, "pos", "neg"))
        condition_label <- paste(rc, psi_label, "res", sep = "_")
        table_name <- paste(metric, condition_label, sep = "_")
        
        # Store the table in the list with the corrected naming
        tables_list[[table_name]] <- wide_df
      }
    }
  }
  
  return(tables_list)
}

list_of_tables <- report_analysis(results_df, models)

# Access a specific table
bias_no_res_table <- list_of_tables[["Bias_0_pos_res"]] # Example for Bias with no residual correlations

#display all tables
report_analysis(results_df, models)
```


# Questions
Open questions: 
- What with this?

if (N<inf_val){
    dat <- MASS::mvrnorm(n=N, mu=rep(0,6), Sigma=S)
    S <- cov(dat) * (N-1) / N
}

- How exactly do we compute Bias, SD and RMSE for the estimated factor correlation?
Absolute vs. relative vs. mean bias in first studies?
```{r}
#Performance measures need to be extracted for each condition
#Below, just mathematical computation, does not work so commented out

#average_absolute_bias <- mean(abs(estimates - true_values))
#average_relative_bias <- mean((estimates - true_values) / true_values) 
```







