# Load necessary libraries
library(lavaan)
library(Matrix)

# Function to generate lavaan model syntax from model matrices
gen_pop_model_syntax <- function(MLIST, ov.prefix = "y", lv.prefix = "f", include.values = TRUE) {
  
  LAMBDA <- MLIST$lambda
  THETA  <- MLIST$theta
  PSI    <- MLIST$psi
  BETA   <- MLIST$beta
  
  # Check prefix
  if (ov.prefix == lv.prefix) {
    stop("lavaan ERROR: ov.prefix can not be the same as lv.prefix")
  }
  
  header <- "# syntax generated by gen_pop_model_syntax()"
  
  # LAMBDA
  if (!is.null(LAMBDA)) {
    IDXV <- row(LAMBDA)[(LAMBDA != 0)]
    IDXF <- col(LAMBDA)[(LAMBDA != 0)]
    
    IDXV <- as.integer(sapply(unique(IDXF), function(j) {
      ji <- IDXV[which(IDXF == j)]  # non-zero loadings for factor j
      j1 <- which(abs(LAMBDA[ji, j] - 1) < .Machine$double.eps)
      ji[c(1, j1)] <- ji[c(j1, 1)]
      return(ji)
    }))
    
    nel <- length(IDXF)
    lambda.txt <- character(nel)
    for (i in seq_len(nel)) {
      if (include.values) {
        lambda.txt[i] <- paste0(paste0(lv.prefix, IDXF[i]), " =~ ",
                                LAMBDA[IDXV[i], IDXF[i]], "*",
                                paste0(ov.prefix, IDXV[i]))
      } else {
        lambda.txt[i] <- paste0(paste0(lv.prefix, IDXF[i]), " =~ ",
                                paste0(ov.prefix, IDXV[i]))
      }
    }
  } else {
    lambda.txt <- character(0L)
  }
  
  # THETA
  if (!is.null(THETA)) {
    IDX1 <- row(THETA)[(THETA != 0) & upper.tri(THETA, diag = TRUE)]
    IDX2 <- col(THETA)[(THETA != 0) & upper.tri(THETA, diag = TRUE)]
    nel <- length(IDX1)
    theta.txt <- character(nel)
    for (i in seq_len(nel)) {
      if (include.values) {
        theta.txt[i] <- paste0(paste0(ov.prefix, IDX1[i]), " ~~ ",
                               THETA[IDX1[i], IDX2[i]], "*",
                               paste0(ov.prefix, IDX2[i]))
      } else {
        theta.txt[i] <- paste0(paste0(ov.prefix, IDX1[i]), " ~~ ",
                               paste0(ov.prefix, IDX2[i]))
      }
    }
  } else {
    theta.txt <- character(0L)
  }
  
  # PSI
  if (!is.null(PSI)) {
    IDX1 <- row(PSI)[(PSI != 0) & upper.tri(PSI, diag = TRUE)]
    IDX2 <- col(PSI)[(PSI != 0) & upper.tri(PSI, diag = TRUE)]
    nel <- length(IDX1)
    psi.txt <- character(nel)
    for (i in seq_len(nel)) {
      if (include.values) {
        psi.txt[i] <- paste0(paste0(lv.prefix, IDX1[i]), " ~~ ",
                             PSI[IDX1[i], IDX2[i]], "*",
                             paste0(lv.prefix, IDX2[i]))
      } else {
        psi.txt[i] <- paste0(paste0(lv.prefix, IDX1[i]), " ~~ ",
                             paste0(lv.prefix, IDX2[i]))
      }
    }
  } else {
    psi.txt <- character(0L)
  }
  
  # BETA
  if (!is.null(BETA)) {
    IDX1 <- row(BETA)[(BETA != 0)]
    IDX2 <- col(BETA)[(BETA != 0)]
    nel <- length(IDX1)
    beta.txt <- character(nel)
    for (i in seq_len(nel)) {
      if (include.values) {
        beta.txt[i] <- paste0(paste0(lv.prefix, IDX1[i]), " ~ ",
                              BETA[IDX1[i], IDX2[i]], "*",
                              paste0(lv.prefix, IDX2[i]))
      } else {
        beta.txt[i] <- paste0(paste0(lv.prefix, IDX1[i]), " ~ ",
                              paste0(lv.prefix, IDXF[i]))
      }
    }
  } else {
    beta.txt <- character(0L)
  }
  
  # Assemble
  syntax <- paste(c(header, lambda.txt, theta.txt, psi.txt, beta.txt, ""),
                  collapse = "\n")
  
  return(syntax)
}
